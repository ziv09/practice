async syncNow(options) {
        const { userId, pendingOperations } = get();
        if (!userId) return;

        const config = { push: true, pull: true, ...options };
        set({ syncStatus: "syncing", syncError: undefined });
        try {
          if (config.push && pendingOperations.length > 0) {
            await pushPendingOperations(userId, pendingOperations);
            await db.operations.clear();
            set({ pendingOperations: [] });
          }
          if (config.pull) {
            const remote = await fetchRemoteSnapshot(userId);
            if (remote?.snapshot) {
              await get().importSnapshot(remote.snapshot);
            } else {
              const localSnapshot = await get().exportSnapshot();
              await upsertRemoteSnapshot(userId, localSnapshot);
            }
          } else if (config.push) {
            const localSnapshot = await get().exportSnapshot();
            await upsertRemoteSnapshot(userId, localSnapshot);
          }

          const timestamp = nowIso();
          const current = get().settings;
          const nextSettings: AppSettings = { ...current, sync: { ...current.sync, lastSyncedAt: timestamp, lastError: undefined } };
          await db.settings.put(nextSettings);
          set({ settings: nextSettings, syncStatus: "idle" });
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          const current = get().settings;
          const nextSettings: AppSettings = { ...current, sync: { ...current.sync, lastError: message } };
          await db.settings.put(nextSettings);
          set({ syncStatus: "error", syncError: message, settings: nextSettings });
        }
      },
      async addTask(input) {
        const id = input.id ?? createId("task");
        const color = input.color ?? DEFAULT_COLOR_PALETTE[Math.floor(Math.random() * DEFAULT_COLOR_PALETTE.length)];
        const payload: PracticeTask = {
          order: get().tasks.length,
          allowReminder: true,
          includeInDashboard: true,
          isActive: true,
          ...input,
          color,
          id
        };
        await db.tasks.put(payload);
        set({ tasks: [...get().tasks, payload] });
        await registerOperation("task.upsert", payload);
        await registerSheetOperation("task.upsert", payload);
        return id;
      },
      async updateTask(id, update) {
        await db.tasks.update(id, update);
        set({ tasks: get().tasks.map((task) => (task.id === id ? { ...task, ...update } : task)) });
        const task = get().tasks.find((item) => item.id === id);
        if (task) {
          await registerOperation("task.upsert", task);
          await registerSheetOperation("task.upsert", task);
        }
      },
      async reorderTasks(ids) {
        const current = get().tasks;
        const updated = ids.map((taskId, index) => ({ ...(current.find((t) => t.id === taskId) as PracticeTask), order: index }));
        await db.tasks.bulkPut(updated);
        set({ tasks: updated });
        await registerOperation("task.upsert", updated);
      },
      async removeTask(id) {
        await db.transaction("rw", db.tasks, db.records, db.goals, async () => {
          await db.records.where({ taskId: id }).delete();
          await db.goals.where({ taskId: id }).delete();
          await db.tasks.delete(id);
        });
        set({
          tasks: get().tasks.filter((t) => t.id !== id),
          records: get().records.filter((r) => r.taskId !== id),
          goals: get().goals.filter((g) => g.taskId !== id)
        });
        await registerOperation("task.delete", { id });
        await get().syncNow({ push: true, pull: false });
        await registerSheetOperation("task.delete", { id });
      },
      async addDailyRecord(input) {
        const id = buildRecordKey(input.taskId, input.date);
        const payload: DailyRecord = { ...input, id, lastModified: nowIso() };
        await db.records.put(payload);
        const filtered = get().records.filter((record) => record.taskId !== input.taskId || record.date !== input.date);
        set({ records: [...filtered, payload] });
        await registerOperation("record.upsert", payload);
        await registerSheetOperation("record.upsert", payload);
      },
      async removeDailyRecord(taskId, date) {
        const id = buildRecordKey(taskId, date);
        await db.records.delete(id);
        set({ records: get().records.filter((r) => !(r.taskId === taskId && r.date === date)) });
        await registerOperation("record.delete", { id, taskId, date });
        await registerSheetOperation("record.delete", { id, taskId, date });
        await get().syncNow({ push: true, pull: false });
      },
      async bulkUpsertDailyRecords(records) {
        const stamped = records.map((record) => ({ ...record, id: buildRecordKey(record.taskId, record.date), lastModified: nowIso() }));
        await db.records.bulkPut(stamped);
        const map = new Map<string, DailyRecord>();
        [...get().records, ...stamped].forEach((record) => map.set(buildRecordKey(record.taskId, record.date), record));
        set({ records: Array.from(map.values()) });
        await registerOperation("record.upsert", stamped);
        await registerSheetOperation("record.upsert", stamped);
      },
      async addGoal(input) {
        const id = input.id ?? createId("goal");
        const payload: PracticeGoal = { ...input, id, createdAt: nowIso() };
        await db.goals.put(payload);
        set({ goals: [...get().goals, payload] });
        await registerOperation("goal.upsert", payload);
        return id;
      },
      async updateGoal(id, update) {
        await db.goals.update(id, update);
        set({ goals: get().goals.map((goal) => (goal.id === id ? { ...goal, ...update } : goal)) });
        const goal = get().goals.find((item) => item.id === id);
        if (goal) await registerOperation("goal.upsert", goal);
      },
      async removeGoal(id) {
        await db.goals.delete(id);
        set({ goals: get().goals.filter((goal) => goal.id !== id) });
        await registerOperation("goal.delete", { id });
        await get().syncNow({ push: true, pull: false });
      },
      async addJournalEntry(input) {
        const id = input.id ?? createId("journal");
        const now = nowIso();
        const payload: JournalEntry = { ...input, id, createdAt: now, updatedAt: now };
        await db.journal.put(payload);
        set({ journalEntries: [...get().journalEntries, payload] });
        await registerOperation("journal.upsert", payload);
        return id;
      },
      async updateJournalEntry(id, update) {
        const existing = get().journalEntries.find((item) => item.id === id);
        if (!existing) return;
        const updatedEntry: JournalEntry = { ...existing, ...update, updatedAt: nowIso() };
        await db.journal.put(updatedEntry);
        set({ journalEntries: get().journalEntries.map((entry) => (entry.id === id ? updatedEntry : entry)) });
        await registerOperation("journal.upsert", updatedEntry);
      },
      async removeJournalEntry(id) {
        await db.journal.delete(id);
        set({ journalEntries: get().journalEntries.filter((entry) => entry.id !== id) });
        await registerOperation("journal.delete", { id });
        await get().syncNow({ push: true, pull: false });
      },
      async setWidgets(widgets) {
        await db.widgets.clear();
        await db.widgets.bulkPut(widgets);
        set({ widgets });
        await registerOperation("widget.upsert", widgets);
      },
      async updateSettings(update) {
        const current = get().settings;
        const nextSettings: AppSettings = {
          ...current,
          ...update,
          appearance: { ...current.appearance, ...(update?.appearance ?? {}) },
          reminder: { ...current.reminder, ...(update?.reminder ?? {}) },
          sync: { ...current.sync, ...(update?.sync ?? {}) },
          id: SETTINGS_ID
        };
        await db.settings.put(nextSettings);
        set({ settings: nextSettings });
        await registerOperation("settings.update", nextSettings);
        if (get().userId) {
          await get().syncNow();
        }
      },
      async updateReminderRules(rules) {
        const current = get().settings;
        const nextSettings: AppSettings = { ...current, reminder: { ...current.reminder, rules }, id: SETTINGS_ID } as AppSettings;
        await db.settings.put(nextSettings);
        set({ settings: nextSettings });
        await registerOperation("settings.update", nextSettings);
      },
      async addCategory(name) {
        const id = createId("cat");
        const item: Category = { id, name, createdAt: nowIso() };
        await db.categories.put(item);
        set({ categories: [...get().categories, item] });
        return id;
      },
      async removeCategory(id) {
        const categories = get().categories.filter((c) => c.id !== id);
        await db.categories.delete(id);
        const removed = get().categories.find((c) => c.id === id);
        if (removed) {
          const affected = get().tasks
            .filter((t) => t.category === removed.name)
            .map((t) => ({ ...t, category: "" }));
          if (affected.length) {
            await db.tasks.bulkPut(affected as any);
            set({ tasks: get().tasks.map((t) => (t.category === removed.name ? { ...t, category: "" } : t)) });
          }
        }
        set({ categories });
      },
      async exportSnapshot() {
        const state: PracticeStateSnapshot = {
          tasks: await db.tasks.toArray(),
          records: await db.records.toArray(),
          goals: await db.goals.toArray(),
          journalEntries: await db.journal.toArray(),
          widgets: await db.widgets.toArray(),
          journalTemplates: await db.templates.toArray(),
          settings: (await db.settings.get(SETTINGS_ID)) ?? defaultSettings,
          categories: await db.categories.toArray(),
          version: 1
        };
        return state;
      },
      async importSnapshot(snapshot) {
        await Dexie.waitFor(
          db.transaction(
            "rw",
            db.tasks,
            db.records,
            db.goals,
            db.journal,
            db.widgets,
            db.templates,
            db.settings,
            db.categories,
            async () => {
              await Promise.all([
                db.tasks.clear(),
                db.records.clear(),
                db.goals.clear(),
                db.journal.clear(),
                db.widgets.clear(),
                db.templates.clear(),
                db.settings.clear(),
                db.categories.clear()
              ]);
              await Promise.all([
                db.tasks.bulkPut(snapshot.tasks),
                db.records.bulkPut(snapshot.records),
                db.goals.bulkPut(snapshot.goals),
                db.journal.bulkPut(snapshot.journalEntries),
                db.widgets.bulkPut(snapshot.widgets),
                db.templates.bulkPut(snapshot.journalTemplates),
                db.settings.put({ ...snapshot.settings, id: SETTINGS_ID }),
                db.categories.bulkPut(snapshot.categories ?? [])
              ]);
            }
          )
        );
        set({
          tasks: snapshot.tasks,
          records: snapshot.records,
          goals: snapshot.goals,
          journalEntries: snapshot.journalEntries,
          widgets: snapshot.widgets,
          journalTemplates: snapshot.journalTemplates,
          settings: { ...snapshot.settings, id: SETTINGS_ID },
          categories: snapshot.categories ?? []
        });
      }
    };
  }, { name: "practice-store" })
);
